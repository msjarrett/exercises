#[derive(Debug, PartialEq)]
pub enum ParseError {
    InvalidSize,
}

#[derive(Debug)]
pub struct Grid {
    pub width: usize,
    pub height: usize,
    pub cells: Vec<Vec<char>>,
}

impl Grid {
    // TODO: Is there a view type I can use instead of Vec?
    // TODO: Should I template this?
    pub fn from_lines(lines: &Vec<String>) -> Result<Grid, ParseError> {
        let width = lines[0].len();
        let height = lines.len();

        let mut cells: Vec<Vec<char>> = Vec::with_capacity(height);
        for line in lines {
            if line.len() != width {
                return Err(ParseError::InvalidSize);
            }
            let mut row: Vec<char> = Vec::with_capacity(width);
            for c in line.chars() {
                row.push(c);
            }
            cells.push(row);
        }

        Ok(Grid {
            width,
            height,
            cells,
        })
    }

    pub fn at(&self, x: usize, y: usize) -> char {
        self.cells[y][x]
    }

    pub fn set(&mut self, x: usize, y: usize, value: char) {
        self.cells[y][x] = value;
    }

    pub fn iter(&self) -> GridIterator<'_> {
        GridIterator::for_grid(self)
    }

    pub fn iter_adjacent(&self, x: usize, y: usize) -> GridIterator<'_> {
        GridIterator::for_adjacent(self, x, y)
    }
}

pub struct GridIterator<'a> {
    grid: &'a Grid,
    x: usize,
    y: usize,

    min_x: usize,
    max_x: usize,
    #[allow(unused)]  // Don't need it, but it's REALLY weird looking to not have it.
    min_y: usize,
    max_y: usize,

    exclude_x: usize,
    exclude_y: usize,
}

impl<'a> GridIterator<'a> {
    fn for_grid(grid: &'a Grid) -> GridIterator<'a> {
        GridIterator {
            grid,
            x: 0,
            y: 0,
            min_x: 0,
            max_x: grid.width - 1,
            min_y: 0,
            max_y: grid.height - 1,
            exclude_x: usize::MAX,
            exclude_y: usize::MAX,
        }
    }

    fn for_adjacent(grid: &'a Grid, x: usize, y: usize) -> GridIterator<'a> {
        let min_x = if x == 0 { 0 } else { x - 1 };
        let min_y = if y == 0 { 0 } else { y - 1 };

        let max_x = if x == grid.width - 1 {
            grid.width - 1
        } else {
            x + 1
        };

        let max_y = if y == grid.height - 1 {
            grid.height - 1
        } else {
            y + 1
        };

        GridIterator {
            grid,
            x: min_x,
            y: min_y,
            min_x: min_x,
            max_x: max_x,
            min_y: min_y,
            max_y: max_y,
            exclude_x: x,
            exclude_y: y,
        }
    }
}

impl<'a> Iterator for GridIterator<'a> {
    type Item = (usize, usize, char);

    fn next(&mut self) -> Option<Self::Item> {
        // Handle top-left corner exclude. We will automatically skip the exclude unless it's the very first position in the iterator.
        if self.x == self.exclude_x && self.y == self.exclude_y {
            self.x += 1;
            if self.x > self.max_x {
                self.x = self.min_x;
                self.y += 1;
            }
        }

        // Exit condition.
        if self.y > self.max_y {
            return None;
        }

        // Retrieve and increment.
        let item = (self.x, self.y, self.grid.at(self.x, self.y));

        self.x += 1;
        if self.x == self.exclude_x && self.y == self.exclude_y {
            self.x += 1
        }
        if self.x > self.max_x {
            self.x = self.min_x;
            self.y += 1;
        }

        Some(item)
    }
}

// Note: Unit tests completely generated by Gemini Code Assist.
#[cfg(test)]
mod tests {
    use super::*;

    fn sample_grid() -> Grid {
        let lines = vec!["abc".to_string(), "def".to_string(), "ghi".to_string()];
        Grid::from_lines(&lines).unwrap()
    }

    #[test]
    fn test_from_lines_valid() {
        let grid = sample_grid();
        assert_eq!(grid.width, 3);
        assert_eq!(grid.height, 3);
        assert_eq!(grid.cells[0][0], 'a');
        assert_eq!(grid.cells[1][1], 'e');
        assert_eq!(grid.cells[2][2], 'i');
    }

    #[test]
    fn test_from_lines_invalid_size() {
        let lines = vec!["ab".to_string(), "cde".to_string()];
        let result = Grid::from_lines(&lines);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), ParseError::InvalidSize);
    }

    #[test]
    fn test_at() {
        let grid = sample_grid();
        assert_eq!(grid.at(0, 0), 'a');
        assert_eq!(grid.at(1, 0), 'b');
        assert_eq!(grid.at(2, 1), 'f');
    }

    #[test]
    fn test_set() {
        let mut grid = sample_grid();
        grid.set(1, 1, 'X');
        assert_eq!(grid.at(1, 1), 'X');
    }

    #[test]
    fn test_iter() {
        let grid = sample_grid();
        let mut iter = grid.iter();
        assert_eq!(iter.next(), Some((0, 0, 'a')));
        assert_eq!(iter.next(), Some((1, 0, 'b')));
        assert_eq!(iter.next(), Some((2, 0, 'c')));
        assert_eq!(iter.next(), Some((0, 1, 'd')));
        assert_eq!(iter.next(), Some((1, 1, 'e')));
        assert_eq!(iter.next(), Some((2, 1, 'f')));
        assert_eq!(iter.next(), Some((0, 2, 'g')));
        assert_eq!(iter.next(), Some((1, 2, 'h')));
        assert_eq!(iter.next(), Some((2, 2, 'i')));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn test_iter_collect() {
        let grid = sample_grid();
        let items: Vec<_> = grid.iter().collect();
        assert_eq!(items.len(), 9);
        assert_eq!(items[4], (1, 1, 'e'));
    }

    #[test]
    fn test_iter_adjacent_center() {
        let grid = sample_grid();
        let mut items: Vec<_> = grid.iter_adjacent(1, 1).collect();
        items.sort();
        let mut expected = vec![
            (0, 0, 'a'),
            (1, 0, 'b'),
            (2, 0, 'c'),
            (0, 1, 'd'),
            (2, 1, 'f'),
            (0, 2, 'g'),
            (1, 2, 'h'),
            (2, 2, 'i'),
        ];
        expected.sort();
        assert_eq!(items, expected);
    }

    #[test]
    fn test_iter_adjacent_top_left() {
        let grid = sample_grid();
        let mut items: Vec<_> = grid.iter_adjacent(0, 0).collect();
        items.sort();
        let mut expected = vec![(1, 0, 'b'), (0, 1, 'd'), (1, 1, 'e')];
        expected.sort();
        assert_eq!(items, expected);
    }

    #[test]
    fn test_iter_adjacent_bottom_right() {
        let grid = sample_grid();
        let mut items: Vec<_> = grid.iter_adjacent(2, 2).collect();
        items.sort();
        let mut expected = vec![(1, 1, 'e'), (2, 1, 'f'), (1, 2, 'h')];
        expected.sort();
        assert_eq!(items, expected);
    }

    #[test]
    fn test_iter_adjacent_on_1x1_grid() {
        let lines = vec!["a".to_string()];
        let grid = Grid::from_lines(&lines).unwrap();
        let items: Vec<_> = grid.iter_adjacent(0, 0).collect();
        assert!(items.is_empty());
    }
}
